<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
<title>Rompecabezas de Sonidos ðŸŽµ</title>
<style>
  :root{
    --bg1: #ffe4ec;
    --bg2: #e6e6fa;
    --accent: #b54b7a;
    --accent-2: #ff6ec7;
  }
  body{
    margin:0;
    font-family: 'Poppins',sans-serif;
    background: linear-gradient(135deg,var(--bg1),var(--bg2));
    color:#333;
    display:flex;
    flex-direction:column;
    align-items:center;
    min-height:100vh;
    padding:18px;
    box-sizing:border-box;
  }

  h1{
    font-family:'Dancing Script',cursive;
    font-size:1.6rem;
    margin:6px 0 2px 0;
    color:var(--accent);
  }
  p.lead{
    margin:0 0 14px 0;
    color:#6a4c93;
    text-align:center;
    font-size:0.95rem;
  }

  #game {
    width:100%;
    max-width:420px;
    display:flex;
    flex-direction:column;
    gap:14px;
    align-items:center;
  }

  /* panel de botones 3x3 */
  .grid {
    display:grid;
    grid-template-columns:repeat(3,1fr);
    gap:10px;
    width:100%;
    max-width:360px;
  }
  .pad {
    aspect-ratio:1/1;
    border-radius:12px;
    display:flex;
    align-items:center;
    justify-content:center;
    background:linear-gradient(180deg,#fff,#ffeef8);
    box-shadow:0 6px 18px rgba(0,0,0,0.12);
    font-size:1.1rem;
    user-select:none;
    -webkit-user-select:none;
    touch-action: manipulation;
    transition: transform .12s ease, box-shadow .12s ease;
    border:2px solid rgba(0,0,0,0.04);
  }
  .pad:active { transform: scale(.98); }
  .pad.on {
    transform: scale(1.06);
    box-shadow: 0 12px 30px rgba(255,110,199,0.25);
    border-color: rgba(181,75,122,0.9);
    background: linear-gradient(180deg,#ffd9ee,#ffecf8);
  }
  .pad .label { color:var(--accent); font-weight:600; }

  /* controles */
  .controls {
    width:100%;
    max-width:360px;
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    justify-content:center;
  }
  .controls button {
    flex:1 1 auto;
    min-width:120px;
    padding:10px;
    border-radius:12px;
    border:none;
    background:var(--accent);
    color:#fff;
    font-weight:600;
    box-shadow:0 6px 18px rgba(0,0,0,0.12);
  }
  .controls button.secondary {
    background: #fff;
    color: var(--accent);
    border: 2px solid #f0dbea;
  }
  .status{
    width:100%;
    max-width:360px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    font-weight:600;
    color:#6a4c93;
  }

  /* overlay final */
  .overlay {
    position:fixed;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    background: rgba(0,0,0,0.45);
    z-index:50;
  }
  .overlay.show { display:flex; }
  .modal {
    background: #fff;
    padding:18px;
    border-radius:14px;
    width:90%;
    max-width:360px;
    text-align:center;
    box-shadow:0 12px 40px rgba(0,0,0,0.35);
  }
  .modal h2{ margin:0 0 8px 0; color:var(--accent); }
  .modal p{ margin:0 0 12px 0; color:#555; }

  /* pequeÃ±a animaciÃ³n de brillo */
  .spark {
    position:absolute;
    width:12px; height:12px;
    border-radius:50%;
    background: radial-gradient(circle,#fff,#ffd9ee 40%,transparent 60%);
    filter: blur(6px);
    opacity:0;
    pointer-events:none;
    animation: pop .9s linear forwards;
  }
  @keyframes pop{
    0% { transform: translateY(0) scale(.3); opacity:1; }
    100% { transform: translateY(-60px) scale(1.6); opacity:0; }
  }

  /* responsive tweaks */
  @media (max-width:420px){
    .pad { border-radius:10px; }
    h1{ font-size:1.4rem; }
  }
</style>
</head>
<body>
  <h1>Rompecabezas de Sonidos ðŸŽ¶</h1>
  <p class="lead">Escucha la secuencia y repÃ­tela. Cada nivel la secuencia aumenta. Â¡Completa la melodÃ­a para ver la sorpresa! âœ¨</p>

  <div id="game">
    <div class="status">
      <div>Level: <span id="level">0</span></div>
      <div>Intentos: <span id="tries">0</span></div>
    </div>

    <div class="grid" id="grid">
      <!-- 9 pads se generarÃ¡n por JS si quieres, pero los predefinimos aquÃ­ -->
      <div class="pad" data-id="0"><div class="label">Do</div></div>
      <div class="pad" data-id="1"><div class="label">Re</div></div>
      <div class="pad" data-id="2"><div class="label">Mi</div></div>
      <div class="pad" data-id="3"><div class="label">Fa</div></div>
      <div class="pad" data-id="4"><div class="label">Sol</div></div>
      <div class="pad" data-id="5"><div class="label">La</div></div>
      <div class="pad" data-id="6"><div class="label">Si</div></div>
      <div class="pad" data-id="7"><div class="label">Doâ™¯</div></div>
      <div class="pad" data-id="8"><div class="label">Reâ™¯</div></div>
    </div>

    <div class="controls">
      <button id="startBtn">Iniciar juego</button>
      <button id="repeatBtn" class="secondary">Repetir secuencia</button>
    </div>
  </div>

  <!-- overlay para final / mensajes -->
  <div class="overlay" id="overlay">
    <div class="modal" id="modal">
      <h2 id="modalTitle">Â¡Felicidades!</h2>
      <p id="modalMsg">Has completado la melodÃ­a ðŸŽ‰</p>
      <button id="modalClose">Cerrar</button>
    </div>
  </div>

<script>
/*
  Rompecabezas de Sonidos - lÃ³gica
  - 9 pads (0..8) con sonidos s1..s9 (archivos s1.mp3 ... s9.mp3)
  - Simon-like: el juego genera una secuencia que se reproduce; usuario repite.
  - Cada nivel se aÃ±ade 1 nota.  Nivel objetivo muy jugable.
  - Funciona en mÃ³vil: toca pads; pads se iluminan y reproducen sonido.
  - Si no encuentra los archivos de audio, usa WebAudio oscillator como fallback.
*/

// Config
const pads = Array.from(document.querySelectorAll('.pad'));
const levelEl = document.getElementById('level');
const triesEl = document.getElementById('tries');
const startBtn = document.getElementById('startBtn');
const repeatBtn = document.getElementById('repeatBtn');
const overlay = document.getElementById('overlay');
const modalTitle = document.getElementById('modalTitle');
const modalMsg = document.getElementById('modalMsg');
const modalClose = document.getElementById('modalClose');

const AUDIO_PREFIX = 's'; // archivos: s1.mp3 ... s9.mp3  (coloca s1.mp3 ... s9.mp3)
const VICTORY_AUDIO = 'victoria.mp3'; // opcional

let sequence = [];
let userIndex = 0;
let level = 0;
let tries = 0;
let playingSequence = false;
let audioCtx = null;
let audios = []; // HTMLAudioElements or null (if fallback)

// init audio
function initAudio() {
  // try create AudioContext
  try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e){ audioCtx = null; }
  // try load audio files
  for (let i=1;i<=9;i++){
    const path = `${AUDIO_PREFIX}${i}.mp3`;
    const a = new Audio(path);
    a.preload = 'auto';
    // If it fails to load, we'll detect later
    audios[i-1] = a;
  }
  // victory
  audios.victory = new Audio(VICTORY_AUDIO);
}

// play using HTMLAudioElement if available; otherwise oscillator beep
function playSound(index, duration = 400) {
  if (audios[index] && audios[index].readyState >= 2) {
    const a = audios[index].cloneNode();
    a.volume = 0.9;
    a.play().catch(()=>{ /* ignore play error */ });
    return;
  }
  // fallback: webaudio beep with frequency map
  if (audioCtx) {
    const freqMap = [261.6,293.7,329.6,349.2,392.0,440.0,493.9,277.2,311.1]; // C D E F G A B C# D#
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = 'sine';
    o.frequency.value = freqMap[index] || 350;
    g.gain.value = 0.00001;
    o.connect(g);
    g.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    g.gain.linearRampToValueAtTime(0.09, now + 0.01);
    o.start(now);
    g.gain.exponentialRampToValueAtTime(0.00001, now + duration/1000);
    o.stop(now + duration/1000 + 0.02);
  }
}

// visual feedback
function lightPad(idx, on=true, short=false){
  const p = pads[idx];
  if(!p) return;
  if(on) p.classList.add('on'); else p.classList.remove('on');
  if(on && short){
    setTimeout(()=>p.classList.remove('on'), 300);
  }
}

// generate next note
function pushNextNote(){
  const next = Math.floor(Math.random()*9);
  sequence.push(next);
}

// play full sequence (async)
async function playSequence(){
  playingSequence = true;
  repeatBtn.disabled = true;
  startBtn.disabled = true;
  for (let i=0;i<sequence.length;i++){
    const idx = sequence[i];
    lightPad(idx,true);
    playSound(idx, 400);
    await sleep(450);
    lightPad(idx,false);
    await sleep(150);
  }
  playingSequence = false;
  repeatBtn.disabled = false;
  startBtn.disabled = false;
  userIndex = 0;
}

// util sleep
function sleep(ms){ return new Promise(res=>setTimeout(res,ms)); }

// start new game
async function startGame(){
  sequence = [];
  level = 0;
  tries = 0;
  levelUp();
}

// level up: add note and play
function levelUp(){
  level++;
  levelEl.textContent = level;
  pushNextNote();
  // small delay then play sequence
  setTimeout(()=>playSequence(), 500);
}

// handle user input (tap/click)
function handleUserInput(idx){
  if(playingSequence) return; // ignore while seq plays
  // play sound and flash
  lightPad(idx,true,true);
  playSound(idx, 300);

  if(sequence[userIndex] === idx){
    userIndex++;
    // completed level
    if(userIndex >= sequence.length){
      // success: small sparkle animation
      successFeedback();
      // next level after small pause
      setTimeout(()=>{ userIndex=0; levelUp(); }, 900);
    }
  } else {
    // wrong
    tries++;
    triesEl.textContent = tries;
    wrongFeedback();
    // give user one more chance: replay sequence
    userIndex = 0;
    setTimeout(()=>playSequence(), 700);
  }
}

// wrong feedback
function wrongFeedback(){
  // flash all pads red-ish quickly
  pads.forEach(p=>p.style.transition='transform .08s');
  pads.forEach(p=>p.classList.add('on'));
  setTimeout(()=>pads.forEach(p=>p.classList.remove('on')), 300);
}

// success feedback
function successFeedback(){
  // create a few spark elements near grid
  for(let i=0;i<8;i++){
    const s = document.createElement('div');
    s.className = 'spark';
    s.style.left = (20 + Math.random()*60) + '%';
    s.style.top = (20 + Math.random()*60) + '%';
    document.body.appendChild(s);
    setTimeout(()=>s.remove(), 900);
  }
  // small victory sound if present
  if(audios.victory && audios.victory.readyState >= 2){
    audios.victory.cloneNode().play().catch(()=>{});
  } else if(audioCtx){
    // short pleasant chord
    const now = audioCtx.currentTime;
    [440,554.4,659.3].forEach((f,i)=>{
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type='sine'; o.frequency.value = f;
      o.connect(g); g.connect(audioCtx.destination);
      g.gain.value = 0.00001;
      g.gain.linearRampToValueAtTime(0.07, now + i*0.02);
      o.start(now + i*0.02);
      g.gain.exponentialRampToValueAtTime(0.00001, now + 0.25 + i*0.02);
      o.stop(now + 0.3 + i*0.02);
    });
  }
}

// attach pad events
pads.forEach((pad, idx)=>{
  // click / touch
  pad.addEventListener('click', ()=> handleUserInput(idx));
  pad.addEventListener('touchstart', (e)=> { e.preventDefault(); handleUserInput(idx); }, {passive:false});
});

// start / repeat
startBtn.addEventListener('click', ()=> startGame());
repeatBtn.addEventListener('click', ()=> { if(!playingSequence) playSequence(); });

// modal controls
modalClose.addEventListener('click', ()=> overlay.classList.remove('show'));

// init audio and set initial UI
initAudio();
levelEl.textContent = level;
triesEl.textContent = tries;

// Optional: autoplay intro sequence to invite to play (small)
setTimeout(()=>{
  // gentle prompt: play a tiny pattern then stop
  sequence = [0,4,7]; // short example
  playSequence();
  sequence = []; // clear demo
},8000);

</script>
</body>
</html>
